#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_key_transposer_creation() {
        let transposer = KeyTransposer::new(Some(&"G".to_string()));
        assert_eq!(transposer.tonic_note, "g");
        assert_eq!(transposer._key_signature.len(), 1);
        assert_eq!(transposer._key_signature[0], (3, true)); // F# 
    }
    
    #[test]
    fn test_degree_to_scale_degree() {
        assert_eq!(degree_to_scale_degree(Degree::N1), ("c", 0));   // Scale degree 1 = C natural
        assert_eq!(degree_to_scale_degree(Degree::N2), ("d", 0));   // Scale degree 2 = D natural 
        assert_eq!(degree_to_scale_degree(Degree::N1s), ("c", 1));  // Scale degree 1 sharp = C#
        assert_eq!(degree_to_scale_degree(Degree::N2b), ("d", -1)); // Scale degree 2 flat = Db
    }
    
    #[test]
    fn test_slur_serialization() {
        let elements = vec![
            StaffNotationElement::SlurStart {},
            StaffNotationElement::SlurEnd {},
        ];
        
        let json = serde_json::to_string(&elements).unwrap();
        println!("Serialized SlurStart/SlurEnd: {}", json);
        
        // Should serialize as objects with type field
        assert!(json.contains(r#""type":"SlurStart""#));
        assert!(json.contains(r#""type":"SlurEnd""#));
    }
    
    #[test]
    fn test_degree_to_vexflow_note_name_sharp_notation() {
        // Test that sharp notes use "#" not "s"
        assert_eq!(degree_to_vexflow_note_name(Degree::N1s), "c#");
        assert_eq!(degree_to_vexflow_note_name(Degree::N2s), "d#");
        assert_eq!(degree_to_vexflow_note_name(Degree::N4s), "f#");
        assert_eq!(degree_to_vexflow_note_name(Degree::N5s), "g#");
        assert_eq!(degree_to_vexflow_note_name(Degree::N6s), "a#");
        
        // Test that flat notes use "b" not "f"
        assert_eq!(degree_to_vexflow_note_name(Degree::N1b), "cb");
        assert_eq!(degree_to_vexflow_note_name(Degree::N2b), "db");
        assert_eq!(degree_to_vexflow_note_name(Degree::N3b), "eb");
        assert_eq!(degree_to_vexflow_note_name(Degree::N6b), "ab");
        assert_eq!(degree_to_vexflow_note_name(Degree::N7b), "bb");
    }
    
    #[test]
    fn test_key_transposer_transpose_pitch() {
        // Test C major key (tonic = C, scale degree 7 = B)
        let transposer = KeyTransposer::new(Some(&"C".to_string()));
        
        // In C major (tonic C), scale degree 7 should be B natural
        let (key, _) = transposer.transpose_pitch(Degree::N7, 0);
        assert!(key.starts_with("b/"), "Expected b/ for scale degree 7 in C major, got: {}", key);
        
        // Test a sharp degree directly to confirm # symbol usage  
        let (key_sharp, _) = transposer.transpose_pitch(Degree::N1s, 0); // Sharp degree
        assert!(key_sharp.contains("#"), "Expected # symbol for sharp degree, got: {}", key_sharp);
        
        // Test D major key (tonic = D, scale degree 7 = C#)
        let transposer_d = KeyTransposer::new(Some(&"D".to_string()));
        let (key_d7, _) = transposer_d.transpose_pitch(Degree::N7, 0);
        // In D major, scale degree 7 should transpose to C# (7th degree above D)
        assert!(key_d7.starts_with("c#/"), "Expected c#/ for scale degree 7 in D major, got: {}", key_d7);
    }
    
}