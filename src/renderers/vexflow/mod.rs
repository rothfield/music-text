use crate::stave_parser::ProcessedStave;
use crate::rhythm_fsm::{Item, Event};

/// Convert staves to VexFlow SVG
pub fn render_vexflow_svg(staves: &[ProcessedStave]) -> String {
    let mut svg = String::new();
    svg.push_str(r#"<svg width="600" height="200" xmlns="http://www.w3.org/2000/svg">"#);
    svg.push_str("\n");
    
    // Background
    svg.push_str("  <rect width=\"600\" height=\"200\" fill=\"#fafafa\" stroke=\"#333\" stroke-width=\"1\"/>");
    svg.push_str("\n");
    
    // Title
    svg.push_str("  <text x=\"20\" y=\"25\" font-family=\"serif\" font-size=\"16\" font-weight=\"bold\" fill=\"#333\">VexFlow-style Musical Notation</text>");
    svg.push_str("\n");
    
    // Staff lines
    let staff_y = 80;
    let staff_width = 500;
    let staff_x = 50;
    
    for i in 0..5 {
        let y = staff_y + i * 10;
        svg.push_str(&format!("  <line x1=\"{}\" y1=\"{}\" x2=\"{}\" y2=\"{}\" stroke=\"#333\" stroke-width=\"1\"/>", 
            staff_x, y, staff_x + staff_width, y));
        svg.push_str("\n");
    }
    
    // Treble clef
    svg.push_str(&format!("  <text x=\"{}\" y=\"{}\" font-family=\"serif\" font-size=\"40\" fill=\"#333\">ùÑû</text>", 
        staff_x + 10, staff_y + 25));
    svg.push_str("\n");
    
    // Time signature
    svg.push_str(&format!("  <text x=\"{}\" y=\"{}\" font-family=\"serif\" font-size=\"16\" fill=\"#333\">4</text>", 
        staff_x + 50, staff_y));
    svg.push_str("\n");
    svg.push_str(&format!("  <text x=\"{}\" y=\"{}\" font-family=\"serif\" font-size=\"16\" fill=\"#333\">4</text>", 
        staff_x + 50, staff_y + 20));
    svg.push_str("\n");
    
    // Notes
    let mut note_x = staff_x + 80;
    
    for stave in staves {
        // For now, just render a placeholder message
        // TODO: Update SVG rendering to work with rhythm items
        for rhythm_item in &stave.rhythm_items {
            if let Item::Beat(beat) = rhythm_item {
                for beat_element in &beat.elements {
                    if let Event::Note { degree, .. } = &beat_element.event {
                        let note_y = match degree {
                        crate::old_models::Degree::N1 => staff_y + 50,  // C below staff
                        crate::old_models::Degree::N2 => staff_y + 45,  // D
                        crate::old_models::Degree::N3 => staff_y + 40,  // E
                        crate::old_models::Degree::N4 => staff_y + 35,  // F
                        crate::old_models::Degree::N5 => staff_y + 30,  // G
                        crate::old_models::Degree::N6 => staff_y + 25,  // A
                        crate::old_models::Degree::N7 => staff_y + 20,  // B
                        _ => staff_y + 20,    // Default to B
                    };
                    
                    // Note head
                    svg.push_str(&format!("  <ellipse cx=\"{}\" cy=\"{}\" rx=\"6\" ry=\"4\" fill=\"#333\"/>", 
                        note_x, note_y));
                    svg.push_str("\n");
                    
                    // Stem
                    svg.push_str(&format!("  <line x1=\"{}\" y1=\"{}\" x2=\"{}\" y2=\"{}\" stroke=\"#333\" stroke-width=\"2\"/>", 
                        note_x + 6, note_y, note_x + 6, note_y - 25));
                    svg.push_str("\n");
                    
                    // Ledger line if needed (for C below staff)
                    if note_y >= staff_y + 45 {
                        svg.push_str(&format!("  <line x1=\"{}\" y1=\"{}\" x2=\"{}\" y2=\"{}\" stroke=\"#333\" stroke-width=\"1\"/>", 
                            note_x - 8, staff_y + 50, note_x + 14, staff_y + 50));
                        svg.push_str("\n");
                    }
                    
                        // TODO: Add slur and beat group indication using new Event structure
                        
                        note_x += 60;
                    }
                }
            } else if let Item::Barline(_, _) = rhythm_item {
                // Barline
                svg.push_str(&format!("  <line x1=\"{}\" y1=\"{}\" x2=\"{}\" y2=\"{}\" stroke=\"#333\" stroke-width=\"2\"/>", 
                    note_x - 10, staff_y, note_x - 10, staff_y + 40));
                svg.push_str("\n");
                note_x += 20;
            }
        }
    }
    
    // Footer
    svg.push_str("  <text x=\"20\" y=\"180\" font-family=\"serif\" font-size=\"10\" fill=\"#999\">Generated by Music Text Parser ‚Ä¢ VexFlow-style rendering</text>");
    svg.push_str("\n");
    
    svg.push_str("</svg>");
    svg
}

/// Convert staves to VexFlow JSON data
pub fn render_vexflow_data(staves: &[ProcessedStave]) -> serde_json::Value {
    let mut notes = Vec::new();
    let mut beats = Vec::new();
    
    for stave in staves {
        for rhythm_item in &stave.rhythm_items {
            match rhythm_item {
                Item::Beat(beat) => {
                    let mut beat_notes = Vec::new();
                    
                    for beat_element in &beat.elements {
                        match &beat_element.event {
                            Event::Note { degree, .. } => {
                                let pitch = match degree {
                                    crate::old_models::Degree::N1 => "c/4",
                                    crate::old_models::Degree::N2 => "d/4",
                                    crate::old_models::Degree::N3 => "e/4",
                                    crate::old_models::Degree::N4 => "f/4",
                                    crate::old_models::Degree::N5 => "g/4",
                                    crate::old_models::Degree::N6 => "a/4",
                                    crate::old_models::Degree::N7 => "b/4",
                                    _ => "c/4",
                                };
                                
                                let duration = match beat_element.subdivisions {
                                    1 => "8",   // eighth note
                                    2 => "q",   // quarter note
                                    3 => "q.",  // dotted quarter
                                    4 => "h",   // half note
                                    _ => "q",   // fallback
                                };
                                
                                let note_data = serde_json::json!({
                                    "keys": [pitch],
                                    "duration": duration,
                                    "subdivisions": beat_element.subdivisions
                                });
                                
                                beat_notes.push(note_data.clone());
                                notes.push(note_data);
                            }
                            Event::Rest => {
                                let duration = match beat_element.subdivisions {
                                    1 => "8r",   // eighth rest
                                    2 => "qr",   // quarter rest
                                    3 => "q.r",  // dotted quarter rest
                                    4 => "hr",   // half rest
                                    _ => "qr",   // fallback
                                };
                                
                                let rest_data = serde_json::json!({
                                    "keys": [],
                                    "duration": duration,
                                    "subdivisions": beat_element.subdivisions
                                });
                                
                                beat_notes.push(rest_data.clone());
                                notes.push(rest_data);
                            }
                        }
                    }
                    
                    beats.push(serde_json::json!({
                        "divisions": beat.divisions,
                        "is_tuplet": beat.is_tuplet,
                        "tuplet_ratio": beat.tuplet_ratio,
                        "notes": beat_notes
                    }));
                }
                Item::Barline(_, _) => {
                    beats.push(serde_json::json!({
                        "type": "barline"
                    }));
                }
                Item::Breathmark => {
                    beats.push(serde_json::json!({
                        "type": "breathmark"
                    }));
                }
                Item::Tonic(_) => {
                    // Tonic declarations don't generate visual elements - skip
                }
            }
        }
    }
    
    serde_json::json!({
        "notes": notes,
        "beats": beats,
        "time_signature": "4/4",
        "clef": "treble"
    })
}