use crate::stave::ProcessedStave;
use crate::rhythm::{Item, Event, Beat};
use crate::rhythm::types::{Degree, SlurRole, ParsedChild, OrnamentType};
use crate::rhythm::converters::BarlineType;
use serde::{Serialize, Deserialize};

/// VexFlow output structures for sophisticated rendering
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VexFlowStave {
    pub notes: Vec<VexFlowElement>,
    pub key_signature: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum VexFlowElement {
    Note {
        keys: Vec<String>,
        duration: String,
        dots: u8,
        accidentals: Vec<VexFlowAccidental>,
        tied: bool,
        beam_start: bool,
        beam_end: bool,
        syl: Option<String>, // Lyrics/syllables
        ornaments: Vec<String>, // Ornament types
    },
    Rest {
        duration: String,
        dots: u8,
    },
    BarLine {
        bar_type: String,
    },
    SlurStart,
    SlurEnd,
    Tuplet {
        notes: Vec<VexFlowElement>,
        divisions: usize,
        ratio: Option<(usize, usize)>, // (notes, in_space_of)
    },
    Breathmark,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VexFlowAccidental {
    pub index: usize,
    pub accidental: String,
}

/// Convert staves to VexFlow SVG - enhanced with sophisticated rendering
pub fn render_vexflow_svg(staves: &[ProcessedStave]) -> String {
    // Generate VexFlow JSON first
    let _vexflow_data = render_vexflow_data(staves);
    
    // Use the VexFlow JSON to render SVG
    let mut svg = String::new();
    svg.push_str(r#"<svg width="800" height="300" xmlns="http://www.w3.org/2000/svg">"#);
    svg.push_str("\n");
    
    // Background
    svg.push_str("  <rect width=\"800\" height=\"300\" fill=\"#fafafa\" stroke=\"#333\" stroke-width=\"1\"/>");
    svg.push_str("\n");
    
    // Title
    svg.push_str("  <text x=\"20\" y=\"25\" font-family=\"serif\" font-size=\"16\" font-weight=\"bold\" fill=\"#333\">VexFlow Professional Notation</text>");
    svg.push_str("\n");
    
    // Staff lines
    let staff_y = 80;
    let staff_width = 700;
    let staff_x = 50;
    
    for i in 0..5 {
        let y = staff_y + i * 10;
        svg.push_str(&format!("  <line x1=\"{}\" y1=\"{}\" x2=\"{}\" y2=\"{}\" stroke=\"#333\" stroke-width=\"1\"/>", 
            staff_x, y, staff_x + staff_width, y));
        svg.push_str("\n");
    }
    
    // Treble clef
    svg.push_str(&format!("  <text x=\"{}\" y=\"{}\" font-family=\"serif\" font-size=\"40\" fill=\"#333\">ùÑû</text>", 
        staff_x + 10, staff_y + 25));
    svg.push_str("\n");
    
    // Time signature
    svg.push_str(&format!("  <text x=\"{}\" y=\"{}\" font-family=\"serif\" font-size=\"16\" fill=\"#333\">4</text>", 
        staff_x + 50, staff_y));
    svg.push_str("\n");
    svg.push_str(&format!("  <text x=\"{}\" y=\"{}\" font-family=\"serif\" font-size=\"16\" fill=\"#333\">4</text>", 
        staff_x + 50, staff_y + 20));
    svg.push_str("\n");
    
    // Enhanced rendering notice
    svg.push_str("  <text x=\"20\" y=\"50\" font-family=\"Arial\" font-size=\"12\" fill=\"#666\">Enhanced VexFlow data available in JSON - use JavaScript renderer for full features</text>");
    svg.push_str("\n");
    
    // Footer
    svg.push_str("  <text x=\"20\" y=\"280\" font-family=\"serif\" font-size=\"10\" fill=\"#999\">Generated by Music Text Parser ‚Ä¢ Professional VexFlow rendering via JSON</text>");
    svg.push_str("\n");
    
    svg.push_str("</svg>");
    svg
}

/// Convert staves to sophisticated VexFlow JSON data with advanced features
pub fn render_vexflow_data(staves: &[ProcessedStave]) -> serde_json::Value {
    let mut staves_data = Vec::new();
    
    for stave in staves {
        let vexflow_stave = convert_stave_to_vexflow(stave);
        staves_data.push(vexflow_stave);
    }
    
    serde_json::json!({
        "staves": staves_data,
        "time_signature": "4/4",
        "clef": "treble",
        "key_signature": "C"
    })
}

/// Convert a single stave to VexFlow format with advanced features
fn convert_stave_to_vexflow(stave: &ProcessedStave) -> VexFlowStave {
    let mut vexflow_elements = Vec::new();
    let mut slur_stack = Vec::new(); // Track slur nesting
    
    // Pre-process to identify which beats need ties
    let beat_items: Vec<&Beat> = stave.rhythm_items.iter()
        .filter_map(|item| match item {
            Item::Beat(beat) => Some(beat),
            _ => None,
        })
        .collect();
    
    let mut beat_index = 0;
    for rhythm_item in &stave.rhythm_items {
        match rhythm_item {
            Item::Beat(beat) => {
                // Check if the next beat is tied to this one
                let next_beat_is_tied = beat_index + 1 < beat_items.len() && 
                                       beat_items[beat_index + 1].tied_to_previous;
                
                if beat.is_tuplet {
                    // Handle tuplet as a group
                    let tuplet_elements = convert_beat_to_vexflow_elements(beat, &mut slur_stack, next_beat_is_tied);
                    let tuplet_ratio = beat.tuplet_ratio.unwrap_or((beat.divisions, next_power_of_2(beat.divisions)));
                    
                    vexflow_elements.push(VexFlowElement::Tuplet {
                        notes: tuplet_elements,
                        divisions: beat.divisions,
                        ratio: Some(tuplet_ratio),
                    });
                } else {
                    // Regular beat - add elements directly
                    let beat_elements = convert_beat_to_vexflow_elements(beat, &mut slur_stack, next_beat_is_tied);
                    vexflow_elements.extend(beat_elements);
                }
                beat_index += 1;
            },
            Item::Barline(barline_type, _tala) => {
                vexflow_elements.push(VexFlowElement::BarLine {
                    bar_type: barline_type_to_vexflow_string(barline_type),
                });
            },
            Item::Breathmark => {
                vexflow_elements.push(VexFlowElement::Breathmark);
            },
            Item::Tonic(_) => {
                // Tonic affects transposition but doesn't generate visual elements
            },
        }
    }
    
    VexFlowStave {
        notes: vexflow_elements,
        key_signature: Some("C".to_string()),
    }
}

/// Convert a beat to VexFlow elements with slur handling
fn convert_beat_to_vexflow_elements(beat: &Beat, slur_stack: &mut Vec<bool>, next_beat_is_tied: bool) -> Vec<VexFlowElement> {
    let mut elements = Vec::new();
    
    for (element_index, beat_element) in beat.elements.iter().enumerate() {
        match &beat_element.event {
            Event::Note { degree, octave, children, slur } => {
                // Handle slur start
                if let Some(slur_role) = slur {
                    match slur_role {
                        SlurRole::Start => {
                            elements.push(VexFlowElement::SlurStart);
                            slur_stack.push(true);
                        },
                        _ => {}
                    }
                }
                
                // Convert note
                let (keys, accidentals) = degree_to_vexflow_key(*degree, *octave);
                let (duration, dots) = convert_tuplet_duration_to_vexflow(beat_element.tuplet_duration);
                
                // Extract syllable from children
                let syllable = children.iter()
                    .find_map(|child| match child {
                        ParsedChild::Syllable { text, .. } => Some(text.clone()),
                        _ => None,
                    });
                
                // Extract ornaments from children  
                let ornaments: Vec<String> = children.iter()
                    .filter_map(|child| match child {
                        ParsedChild::Ornament { kind, .. } => {
                            Some(match kind {
                                OrnamentType::Mordent => "Mordent".to_string(),
                                OrnamentType::Trill => "Trill".to_string(),
                                OrnamentType::Turn => "Turn".to_string(),
                                OrnamentType::Grace => "Grace".to_string(),
                            })
                        },
                        _ => None,
                    }).collect();
                
                // Determine if this note should be marked as tied
                // For VexFlow: only the second note (receiving end) of a tied pair should be marked as tied
                let is_first_element = element_index == 0;
                let is_tied = is_first_element && beat.tied_to_previous;
                
                elements.push(VexFlowElement::Note {
                    keys: vec![keys],
                    duration,
                    dots,
                    accidentals,
                    tied: is_tied,
                    beam_start: false, // Will be determined by beaming logic
                    beam_end: false,
                    syl: syllable,
                    ornaments,
                });
                
                // Handle slur end
                if let Some(slur_role) = slur {
                    match slur_role {
                        SlurRole::End => {
                            elements.push(VexFlowElement::SlurEnd);
                            if !slur_stack.is_empty() {
                                slur_stack.pop();
                            }
                        },
                        _ => {}
                    }
                }
            },
            Event::Rest => {
                let (duration, dots) = convert_tuplet_duration_to_vexflow(beat_element.tuplet_duration);
                
                elements.push(VexFlowElement::Rest {
                    duration,
                    dots,
                });
            },
        }
    }
    
    elements
}

/// Convert Degree and octave to VexFlow key format
fn degree_to_vexflow_key(degree: Degree, octave: i8) -> (String, Vec<VexFlowAccidental>) {
    use Degree::*;
    
    // VexFlow octave: 4 = middle C
    let vexflow_octave = octave + 4;
    
    let (note_name, accidental_str) = match degree {
        // Scale degree 1 (Do/Sa/C)
        N1bb => ("c", Some("bb")), N1b => ("c", Some("b")), N1 => ("c", None),
        N1s => ("c", Some("#")), N1ss => ("c", Some("##")),
        // Scale degree 2 (Re/D)  
        N2bb => ("d", Some("bb")), N2b => ("d", Some("b")), N2 => ("d", None),
        N2s => ("d", Some("#")), N2ss => ("d", Some("##")),
        // Scale degree 3 (Mi/Ga/E)
        N3bb => ("e", Some("bb")), N3b => ("e", Some("b")), N3 => ("e", None),
        N3s => ("e", Some("#")), N3ss => ("e", Some("##")),
        // Scale degree 4 (Fa/Ma/F)
        N4bb => ("f", Some("bb")), N4b => ("f", Some("b")), N4 => ("f", None),
        N4s => ("f", Some("#")), N4ss => ("f", Some("##")),
        // Scale degree 5 (Sol/Pa/G)
        N5bb => ("g", Some("bb")), N5b => ("g", Some("b")), N5 => ("g", None),
        N5s => ("g", Some("#")), N5ss => ("g", Some("##")),
        // Scale degree 6 (La/Dha/A)
        N6bb => ("a", Some("bb")), N6b => ("a", Some("b")), N6 => ("a", None),
        N6s => ("a", Some("#")), N6ss => ("a", Some("##")),
        // Scale degree 7 (Ti/Ni/B)
        N7bb => ("b", Some("bb")), N7b => ("b", Some("b")), N7 => ("b", None),
        N7s => ("b", Some("#")), N7ss => ("b", Some("##")),
    };
    
    let key = if let Some(acc) = accidental_str {
        format!("{}{}/{}", note_name, acc, vexflow_octave)
    } else {
        format!("{}/{}", note_name, vexflow_octave)
    };
    
    // Create VexFlow accidental objects for visual rendering
    let accidentals = if let Some(acc) = accidental_str {
        vec![VexFlowAccidental {
            index: 0,
            accidental: acc.to_string(),
        }]
    } else {
        vec![]
    };
    
    (key, accidentals)
}

/// Convert tuplet duration (fraction) to VexFlow duration and dots
fn convert_tuplet_duration_to_vexflow(duration: fraction::Fraction) -> (String, u8) {
    let numerator = *duration.numer().unwrap() as u32;
    let denominator = *duration.denom().unwrap() as u32;
    
    // Handle standard durations
    match (numerator, denominator) {
        (1, 1) => ("w".to_string(), 0),     // whole
        (1, 2) => ("h".to_string(), 0),     // half
        (3, 4) => ("h".to_string(), 1),     // dotted half
        (1, 4) => ("q".to_string(), 0),     // quarter
        (3, 8) => ("q".to_string(), 1),     // dotted quarter
        (7, 16) => ("q".to_string(), 2),    // double-dotted quarter
        (1, 8) => ("8".to_string(), 0),     // eighth
        (3, 16) => ("8".to_string(), 1),    // dotted eighth
        (1, 16) => ("16".to_string(), 0),   // sixteenth
        (1, 32) => ("32".to_string(), 0),   // thirty-second
        (1, 64) => ("64".to_string(), 0),   // sixty-fourth
        _ => {
            // For complex fractions, find the closest standard duration
            let decimal_value = numerator as f64 / denominator as f64;
            if decimal_value >= 0.75 { ("w".to_string(), 0) }
            else if decimal_value >= 0.375 { ("h".to_string(), 0) }
            else if decimal_value >= 0.1875 { ("q".to_string(), 0) }
            else if decimal_value >= 0.09375 { ("8".to_string(), 0) }
            else if decimal_value >= 0.046875 { ("16".to_string(), 0) }
            else if decimal_value >= 0.0234375 { ("32".to_string(), 0) }
            else { ("64".to_string(), 0) }
        }
    }
}

/// Convert BarlineType to VexFlow string
fn barline_type_to_vexflow_string(barline_type: &BarlineType) -> String {
    match barline_type {
        BarlineType::Single => "single".to_string(),
        BarlineType::Double => "double".to_string(),
        BarlineType::RepeatStart => "repeat-begin".to_string(),
        BarlineType::RepeatEnd => "repeat-end".to_string(),
        BarlineType::RepeatBoth => "double-repeat".to_string(),
        // Note: No Final barline type in old_models - use Double as fallback
    }
}

/// Calculate next power of 2 for tuplet ratios
fn next_power_of_2(n: usize) -> usize {
    if n <= 1 { return 1; }
    let mut power = 1;
    while power < n {
        power *= 2;
    }
    if power == n { power } else { power / 2 }
}