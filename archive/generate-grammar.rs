use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Configuration structure matching systems.json
#[derive(Debug, Deserialize)]
struct Config {
    systems: HashMap<String, SystemConfig>,
    shared_rules: HashMap<String, String>,
}

#[derive(Debug, Deserialize)]
struct SystemConfig {
    pitch_rule: String,
    pitch_definition: String,
    description: String,
}

fn main() {
    let grammar_dir = Path::new("grammar");
    let systems_config_path = grammar_dir.join("systems.json");
    let main_template_path = grammar_dir.join("notation.pest.template");
    let system_template_path = grammar_dir.join("system-specific.template");
    let output_path = grammar_dir.join("notation.pest");

    println!("üéº Generating music-txt grammar from templates...");

    // Read configuration and templates
    let config: Config = {
        let config_content = fs::read_to_string(&systems_config_path)
            .unwrap_or_else(|e| panic!("‚ùå Failed to read systems.json: {}", e));
        serde_json::from_str(&config_content)
            .unwrap_or_else(|e| panic!("‚ùå Failed to parse systems.json: {}", e))
    };

    let main_template = fs::read_to_string(&main_template_path)
        .unwrap_or_else(|e| panic!("‚ùå Failed to read main template: {}", e));

    let system_template = fs::read_to_string(&system_template_path)
        .unwrap_or_else(|e| panic!("‚ùå Failed to read system template: {}", e));

    // Generate system-specific rules for each notation system
    let mut system_specific_rules = String::new();

    for (system_name, system_config) in &config.systems {
        println!("üìù Generating rules for {} notation...", system_name);
        
        let mut system_rules = system_template.clone();
        
        // Replace template variables
        system_rules = system_rules
            .replace("{{SYSTEM}}", system_name)
            .replace("{{PITCH_RULE}}", &system_config.pitch_rule)
            .replace("{{DESCRIPTION}}", &system_config.description);
        
        system_specific_rules.push_str(&format!("\n// {}\n", system_config.description));
        system_specific_rules.push_str(&system_rules);
        system_specific_rules.push('\n');
    }

    // Generate the final grammar file
    let mut final_grammar = main_template.replace("{{SYSTEM_SPECIFIC_RULES}}", &system_specific_rules);

    // Add generation info (without timestamp to avoid rebuilds)
    final_grammar = final_grammar.replace(
        "Generated by: scripts/generate_grammar.js",
        "Generated by: generate-grammar binary"
    );

    // Only write the output file if it's different (to avoid triggering rebuilds)
    let should_write = if output_path.exists() {
        let existing_content = fs::read_to_string(&output_path)
            .unwrap_or_else(|e| panic!("‚ùå Failed to read existing output file: {}", e));
        existing_content != final_grammar
    } else {
        true
    };

    if should_write {
        fs::write(&output_path, &final_grammar)
            .unwrap_or_else(|e| panic!("‚ùå Failed to write output file: {}", e));
        println!("‚úÖ Successfully generated {}", output_path.display());
    } else {
        println!("‚úÖ Grammar file {} is up to date", output_path.display());
    }
    
    // Show statistics
    let lines = final_grammar.lines().count();
    let systems = config.systems.len();
    println!("üìä Generated {} lines for {} notation systems", lines, systems);
    
    // List generated systems
    println!("üéµ Notation systems:");
    for (name, system_config) in &config.systems {
        println!("   ‚Ä¢ {}: {}", name, system_config.description);
    }
}