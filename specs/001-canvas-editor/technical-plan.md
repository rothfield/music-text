# Technical Plan: WYSIWYG Canvas Editor

This document outlines a phased technical approach for building the WYSIWYG Canvas Editor. The core strategy is to leverage the existing, powerful Rust backend (parser, spatial analysis, rhythm analysis, renderers) while building a new, dedicated GUI application from scratch.

## Phase 1: Consolidate the Backend into a Stable, UI-Agnostic Library

The goal of this phase is to treat the existing Rust code as a library (`lib.rs`) that can be called by any frontend, whether it's the current web UI or the future canvas editor.

1.  **Define a Clean API Boundary:** Expose a single, powerful function that takes the `music-text` string and returns a complete, structured representation of the document suitable for rendering. The existing `process_notation` function in `pipeline.rs` is a strong starting point.
2.  **Create a "Render Model":** The API should return a serialized version of the `Document` AST after all parsing and analysis is complete. This model will be the "source of truth" for the UI. It must contain all necessary information to draw the notation: note pitches, positions, durations, slurs, lyrics, beat groups, etc.
3.  **Expose via an API:** Continue using the Axum web server (`web.rs`) to expose this API for the new client. For a highly interactive canvas editor, consider WebSockets in the future for lower-latency communication, but a standard HTTP API is sufficient to start.

**Reusable Code:** This phase almost exclusively uses existing code: `lib.rs`, `pipeline.rs`, `parse/`, `rhythm/`, `spatial/`, and `models/`.

## Phase 2: Build the UI Scaffold and Basic Rendering

This is the "start from scratch" part, but only for the user interface.

1.  **Set up the Application Shell:** Create a new Rust binary project using the chosen GUI framework (e.g., `eGUI`, `Iced`). This will be the main application for the canvas editor.
2.  **Implement the API Client:** The new UI will act as a client to the backend API defined in Phase 1. It will send `music-text` strings and receive the render model.
3.  **Focus on Rendering First (Read-Only):** The first major goal is to simply *display* a `music-text` document.
    *   Call the backend API with a sample document.
    *   Receive the render model.
    *   Use a Rust SVG rendering library (like `resvg`) to draw the SVG output generated by the existing `renderers::lilypond` or `renderers::svg` modules. This provides a high-quality visual representation immediately, without needing to write a new renderer from scratch.

**Reusable Code:** This phase reuses the `renderers/` modules for generating the visual output.

## Phase 3: Implement the Core Interactive Loop

With rendering in place, the canvas can now become interactive.

1.  **Element Picking:** Implement logic to identify which musical element (note, rest, etc.) the user is clicking on. This involves mapping mouse coordinates to the bounding boxes of the rendered SVG elements.
2.  **Introduce the Edit/Response Cycle:**
    *   When a user performs an action (e.g., clicks a note and presses "delete"), the UI sends a command to the backend API (e.g., `{"action": "delete", "element_id": 123}`).
    *   The backend will need a new function to handle these commands. It would load the document, apply the change, and then run the full `process_notation` pipeline again.
    *   It then sends the *new, complete render model* back to the UI.
    *   The UI receives the new model and triggers a full re-render of the canvas.

This creates a robust, unidirectional data flow where the backend remains the single source of truth.

## Phase 4: Incrementally Add Editing Features

Once the core loop is working, features from the specification can be added incrementally. Each new feature is a new type of command sent to the backend.

*   **Add Note:** Click a position on the canvas, send an `{"action": "add_note", "pitch": "S", "position": ...}` command.
*   **Drag Note:** Send `{"action": "move_note", "element_id": 123, "new_position": ...}`.
*   **Apply Slur:** Select multiple notes, send `{"action": "apply_slur", "element_ids": [123, 124, 125]}`.

This approach allows for the methodical construction of the complex editor, building upon a solid foundation and maximizing the reuse of the existing, battle-tested backend logic.
