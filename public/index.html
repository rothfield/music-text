<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Text</title>
    <script src="vexflow-renderer.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 8px;
            background: #fafafa;
        }
        .app {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            overflow: hidden;
        }
        .control-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f6f8fa;
            border-bottom: 1px solid #e1e5e9;
            font-size: 13px;
        }
        .controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        button {
            background: #0969da;
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover { background: #0550ae; }
        button.secondary {
            background: #6f7681;
            color: white;
        }
        button.secondary:hover { background: #656d76; }
        .status {
            font-size: 12px;
            font-weight: 500;
        }
        .status.success { color: #1a7f37; }
        .status.error { color: #cf222e; }
        .status.loading { color: #656d76; }
        textarea {
            width: 100%;
            height: 80px;
            padding: 8px;
            border: none;
            border-bottom: 1px solid #e1e5e9;
            font-family: 'SF Mono', Monaco, Consolas, monospace;
            font-size: 14px;
            resize: vertical;
            outline: none;
        }
        textarea:focus {
            border-bottom-color: #0969da;
        }
        .tabs {
            display: flex;
            background: #f6f8fa;
            border-bottom: 1px solid #e1e5e9;
        }
        .tab {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: #656d76;
        }
        .tab.active {
            color: #24292f;
            border-bottom-color: #fd8c73;
        }
        .tab-content {
            display: none;
            padding: 12px;
            min-height: 300px;
        }
        .tab-content.active {
            display: block;
        }
        #vexflow-output {
            min-height: 200px;
            background: white;
        }
        #json-output {
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, Consolas, monospace;
            font-size: 12px;
            color: #24292f;
            overflow-x: auto;
            line-height: 1.4;
        }
        #lilypond-output {
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, Consolas, monospace;
            font-size: 12px;
            color: #24292f;
            overflow-x: auto;
            line-height: 1.4;
            background: #f6f8fa;
            padding: 12px;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
        }
        #svg-output {
            text-align: center;
        }
        .pipeline-section {
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, Consolas, monospace;
            font-size: 12px;
            color: #24292f;
            overflow-x: auto;
            line-height: 1.4;
            background: #f6f8fa;
            padding: 12px;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
            margin-bottom: 16px;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="control-bar">
            <div class="controls">
                <button onclick="parseMusic()">Parse</button>
                <button onclick="generateSVG()" class="secondary">LilyPond</button>
                <button onclick="clearAll()" class="secondary">Clear</button>
            </div>
            <div id="status" class="status"></div>
        </div>
        
        <textarea id="musicInput" placeholder="Enter music notation like: |S R G M|"></textarea>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('vexflow', this)">VexFlow Draft</div>
            <div class="tab" onclick="switchTab('svg', this)">LilyPond SVG</div>
            <div class="tab" onclick="switchTab('lilypond', this)">LilyPond Src</div>
            <div class="tab" onclick="switchTab('document', this)">Document</div>
            <div class="tab" onclick="switchTab('parser', this)">Parser</div>
            <div class="tab" onclick="switchTab('rhythm', this)">Rhythm</div>
            <div class="tab" onclick="switchTab('spatial', this)">Spatial</div>
            <div class="tab" onclick="switchTab('analyzer', this)">Analyzer</div>
        </div>
        
        <div id="vexflow-tab" class="tab-content active">
            <div id="vexflow-output"></div>
        </div>
        
        <div id="svg-tab" class="tab-content">
            <div id="svg-output">Click "LilyPond" to generate SVG</div>
        </div>
        
        <div id="lilypond-tab" class="tab-content">
            <div id="lilypond-output">Enter music notation above to see LilyPond source</div>
        </div>
        
        <div id="document-tab" class="tab-content">
            <div id="document-output" class="pipeline-section">Enter music notation to see parsed document output</div>
        </div>
        
        <div id="parser-tab" class="tab-content">
            <div id="parser-output" class="pipeline-section">Enter music notation to see parser output</div>
        </div>
        
        <div id="rhythm-tab" class="tab-content">
            <div id="rhythm-output" class="pipeline-section">Enter music notation to see rhythm analyzer output</div>
        </div>
        
        <div id="spatial-tab" class="tab-content">
            <div id="spatial-output" class="pipeline-section">Enter music notation to see spatial analysis output</div>
        </div>
        
        <div id="analyzer-tab" class="tab-content">
            <div id="analyzer-output" class="pipeline-section">Enter music notation to see analyzer output</div>
        </div>
    </div></body>

    <script>
        let currentParseResult = null;
        
        // Local storage functions
        function saveInputText(text) {
            try {
                localStorage.setItem('music-text-input', text);
            } catch (error) {
                console.warn('Failed to save input to localStorage:', error);
            }
        }
        
        function loadInputText() {
            try {
                return localStorage.getItem('music-text-input') || '';
            } catch (error) {
                console.warn('Failed to load input from localStorage:', error);
                return '';
            }
        }
        
        function saveCursorPosition(start, end) {
            try {
                localStorage.setItem('music-text-cursor', JSON.stringify({start, end}));
            } catch (error) {
                console.warn('Failed to save cursor position to localStorage:', error);
            }
        }
        
        function loadCursorPosition() {
            try {
                const saved = localStorage.getItem('music-text-cursor');
                const result = saved ? JSON.parse(saved) : {start: 0, end: 0};
                console.log('ðŸ“ Loaded cursor position from storage:', result);
                return result;
            } catch (error) {
                console.warn('Failed to load cursor position from localStorage:', error);
                return {start: 0, end: 0};
            }
        }
        
        function restoreFocusAndCursor() {
            const musicInput = document.getElementById('musicInput');
            
            // Always focus first
            musicInput.focus();
            
            // Multiple attempts to ensure cursor restoration works
            const restoreCursor = () => {
                const {start, end} = loadCursorPosition();
                const textLength = musicInput.value.length;
                
                // Ensure cursor positions are valid for current text
                const safeStart = Math.min(Math.max(0, start), textLength);
                const safeEnd = Math.min(Math.max(0, end), textLength);
                
                console.log('ðŸ”„ Restoring cursor position:', {start, end, safeStart, safeEnd, textLength});
                
                // Force the selection range
                try {
                    musicInput.setSelectionRange(safeStart, safeEnd);
                    // Verify the position was actually set
                    const actualStart = musicInput.selectionStart;
                    const actualEnd = musicInput.selectionEnd;
                    console.log('âœ… Cursor restored - requested:', safeStart, safeEnd, 'actual:', actualStart, actualEnd);
                } catch (e) {
                    console.warn('Failed to set cursor position:', e);
                }
            };
            
            // Try multiple times to ensure it works
            requestAnimationFrame(restoreCursor);
            setTimeout(restoreCursor, 10);
            setTimeout(restoreCursor, 50);
        }
        
        function saveActiveTab(tabName) {
            try {
                localStorage.setItem('music-text-active-tab', tabName);
            } catch (error) {
                console.warn('Failed to save active tab to localStorage:', error);
            }
        }
        
        function loadActiveTab() {
            try {
                return localStorage.getItem('music-text-active-tab') || 'vexflow';
            } catch (error) {
                console.warn('Failed to load active tab from localStorage:', error);
                return 'vexflow';
            }
        }
        
        function setStatus(message, type = 'loading') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.textContent = message;
            if (type === 'success' || type === 'error') {
                setTimeout(() => status.textContent = '', 3000);
            }
        }
        
        function switchTab(tabName, clickedTab) {
            // Save cursor position BEFORE switching tabs
            const musicInput = document.getElementById('musicInput');
            const currentStart = musicInput.selectionStart;
            const currentEnd = musicInput.selectionEnd;
            if (currentStart !== undefined && currentEnd !== undefined && currentStart >= 0 && currentEnd >= 0) {
                saveCursorPosition(currentStart, currentEnd);
            }
            
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to clicked tab and corresponding content
            if (clickedTab) {
                clickedTab.classList.add('active');
            } else {
                document.querySelector(`[onclick*="${tabName}"]`).classList.add('active');
            }
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // Save active tab to localStorage
            saveActiveTab(tabName);
            
            // ALWAYS restore focus and cursor to textarea
            restoreFocusAndCursor();
        }
        
        // Parse and update VexFlow only (called by keystroke listener)
        async function parseAndUpdateVexFlow() {
            const input = document.getElementById('musicInput').value;
            
            if (!input.trim()) {
                return;
            }
            
            try {
                const response = await fetch(`/api/parse?input=${encodeURIComponent(input)}`);
                const result = await response.json();
                currentParseResult = result;
                
                // Update pipeline sections
                updatePipelineData(result);
                
                // Update LilyPond source tab
                if (result.success && result.lilypond) {
                    document.getElementById('lilypond-output').textContent = result.lilypond;
                } else if (result.success) {
                    document.getElementById('lilypond-output').textContent = 'No LilyPond source available';
                } else {
                    document.getElementById('lilypond-output').textContent = `Parse error: ${result.error}`;
                }
                
                // Update VexFlow preview if we have vexflow data
                if (result.success && result.vexflow) {
                    renderVexFlow(result.vexflow);
                } else if (result.success) {
                    document.getElementById('vexflow-output').innerHTML = '<p>Parsed successfully, but no VexFlow data available.</p>';
                } else {
                    document.getElementById('vexflow-output').innerHTML = `<p>Parse error: ${result.error}</p>`;
                }
                
            } catch (error) {
                console.warn('Parse error during typing:', error.message);
                document.getElementById('vexflow-output').innerHTML = `<p>Parse error: ${error.message}</p>`;
            }
        }
        
        // Manual parse button (shows status messages)
        async function parseMusic() {
            // Save cursor position BEFORE processing
            const musicInput = document.getElementById('musicInput');
            const currentStart = musicInput.selectionStart;
            const currentEnd = musicInput.selectionEnd;
            if (currentStart !== undefined && currentEnd !== undefined && currentStart >= 0 && currentEnd >= 0) {
                saveCursorPosition(currentStart, currentEnd);
            }
            
            const input = musicInput.value;
            
            if (!input.trim()) {
                setStatus('Please enter some music notation.', 'error');
                restoreFocusAndCursor();
                return;
            }
            
            setStatus('Parsing notation...', 'loading');
            
            try {
                const response = await fetch(`/api/parse?input=${encodeURIComponent(input)}`);
                const result = await response.json();
                currentParseResult = result;
                
                // Update pipeline sections
                updatePipelineData(result);
                
                // Update LilyPond source tab
                if (result.success && result.lilypond) {
                    document.getElementById('lilypond-output').textContent = result.lilypond;
                } else if (result.success) {
                    document.getElementById('lilypond-output').textContent = 'No LilyPond source available';
                } else {
                    document.getElementById('lilypond-output').textContent = `Parse error: ${result.error}`;
                }
                
                // Update VexFlow preview if we have vexflow data
                if (result.success && result.vexflow) {
                    renderVexFlow(result.vexflow);
                    setStatus('Parse successful! VexFlow preview updated.', 'success');
                } else if (result.success) {
                    document.getElementById('vexflow-output').innerHTML = '<p>Parsed successfully, but no VexFlow data available.</p>';
                    setStatus('Parse successful! (No VexFlow data)', 'success');
                } else {
                    document.getElementById('vexflow-output').innerHTML = `<p>Parse error: ${result.error}</p>`;
                    setStatus('Parse failed.', 'error');
                }
                
                // Auto-switch to VexFlow tab
                switchTab('vexflow');
                
            } catch (error) {
                setStatus(`Error: ${error.message}`, 'error');
                document.getElementById('json-output').textContent = `Error: ${error.message}`;
                document.getElementById('vexflow-output').innerHTML = `<p>Error: ${error.message}</p>`;
                restoreFocusAndCursor();
            }
        }
        
        function updatePipelineData(result) {
            if (result.success) {
                // Document Output - text-lines, paragraphs, and content lines structure
                const documentStructure = {
                    source: result.parsed_document?.source || null,
                    directives: result.parsed_document?.directives || [],
                    staves: result.parsed_document?.staves?.map(stave => ({
                        text_lines_before: stave.text_lines_before || [],
                        content_line: stave.content_line || [],
                        text_lines_after: stave.text_lines_after || [],
                        upper_lines: stave.upper_lines || [],
                        lower_lines: stave.lower_lines || [],
                        lyrics_lines: stave.lyrics_lines || [],
                        source: stave.source
                    })) || []
                };
                document.getElementById('document-output').textContent = 
                    JSON.stringify(documentStructure, null, 2);
                
                // Parser Output - raw parser + spatial analysis output  
                document.getElementById('parser-output').textContent = 
                    JSON.stringify(result.parsed_document || {}, null, 2);
                
                // Rhythm Output - document after rhythm analyzer
                document.getElementById('rhythm-output').textContent = 
                    JSON.stringify(result.processed_staves || [], null, 2);
                
                // Spatial Analysis Output - document after spatial analysis (with positions)
                document.getElementById('spatial-output').textContent = 
                    JSON.stringify(result.parsed_document || {}, null, 2);
                
                // Analyzer Output - VexFlow data, notation systems, etc.
                const analyzerData = {
                    vexflow: result.vexflow,
                    detected_notation_systems: result.detected_notation_systems,
                    error: result.error
                };
                document.getElementById('analyzer-output').textContent = 
                    JSON.stringify(analyzerData, null, 2);
            } else {
                // Show error in all sections
                const errorMsg = `Parse error: ${result.error}`;
                document.getElementById('document-output').textContent = errorMsg;
                document.getElementById('parser-output').textContent = errorMsg;
                document.getElementById('rhythm-output').textContent = errorMsg;
                document.getElementById('spatial-output').textContent = errorMsg;
                document.getElementById('analyzer-output').textContent = errorMsg;
            }
        }

        async function renderVexFlow(vexflowData) {
            const output = document.getElementById('vexflow-output');
            output.innerHTML = ''; // Clear previous content
            
            try {
                if (window.VexFlowRenderer) {
                    // Use the sophisticated VexFlow renderer
                    const success = await window.VexFlowRenderer.renderVexFlowNotation(vexflowData, 'vexflow-output');
                    if (!success) {
                        output.innerHTML = `<p>VexFlow rendering failed. Showing raw data:</p><pre>${JSON.stringify(vexflowData, null, 2)}</pre>`;
                    }
                } else {
                    output.innerHTML = '<p>VexFlow renderer not loaded. Showing raw data:</p><pre>' + JSON.stringify(vexflowData, null, 2) + '</pre>';
                }
            } catch (error) {
                output.innerHTML = `<p>VexFlow rendering error: ${error.message}</p><pre>${JSON.stringify(vexflowData, null, 2)}</pre>`;
            }
        }

        async function generateSVG() {
            // Save cursor position BEFORE processing
            const musicInput = document.getElementById('musicInput');
            const currentStart = musicInput.selectionStart;
            const currentEnd = musicInput.selectionEnd;
            if (currentStart !== undefined && currentEnd !== undefined && currentStart >= 0 && currentEnd >= 0) {
                saveCursorPosition(currentStart, currentEnd);
            }
            
            const input = musicInput.value;
            
            if (!input.trim()) {
                setStatus('Please enter some music notation.', 'error');
                restoreFocusAndCursor();
                return;
            }
            
            setStatus('Generating LilyPond SVG...', 'loading');
            
            try {
                const response = await fetch(`/api/parse?input=${encodeURIComponent(input)}&generate_svg=true`);
                const result = await response.json();
                currentParseResult = result;
                
                // Update all tabs with fresh data
                updatePipelineData(result);
                
                if (result.success && result.lilypond) {
                    document.getElementById('lilypond-output').textContent = result.lilypond;
                } else if (result.success) {
                    document.getElementById('lilypond-output').textContent = 'No LilyPond source available';
                } else {
                    document.getElementById('lilypond-output').textContent = `Parse error: ${result.error}`;
                }
                
                if (result.success && result.vexflow) {
                    renderVexFlow(result.vexflow);
                }
                
                // Update SVG tab
                if (result.success && result.lilypond_svg) {
                    document.getElementById('svg-output').innerHTML = result.lilypond_svg;
                    setStatus('LilyPond SVG generated successfully!', 'success');
                    // Switch to LilyPond SVG tab (second tab)
                    switchTab('svg');
                } else if (result.success) {
                    let errorMsg = 'SVG generation failed - no SVG content returned. Check server console for LilyPond errors.';
                    if (!result.lilypond) {
                        errorMsg = 'No LilyPond source available to generate SVG from.';
                    }
                    document.getElementById('svg-output').innerHTML = `<p>${errorMsg}</p><details><summary>Debug Info</summary><pre>${JSON.stringify(result, null, 2)}</pre></details>`;
                    setStatus('SVG generation failed.', 'error');
                    restoreFocusAndCursor();
                } else {
                    document.getElementById('svg-output').innerHTML = `<p>Parse error: ${result.error}</p>`;
                    setStatus('Parse failed.', 'error');
                    restoreFocusAndCursor();
                }
            } catch (error) {
                document.getElementById('svg-output').innerHTML = `<p>Error: ${error.message}</p>`;
                setStatus(`Error: ${error.message}`, 'error');
                restoreFocusAndCursor();
            }
        }

        function clearAll() {
            document.getElementById('musicInput').value = '';
            document.getElementById('lilypond-output').textContent = 'Enter music notation above to see LilyPond source';
            document.getElementById('vexflow-output').innerHTML = '';
            document.getElementById('svg-output').innerHTML = 'Click "LilyPond" to generate SVG';
            document.getElementById('document-output').textContent = 'Enter music notation to see document structure';
            document.getElementById('parser-output').textContent = 'Enter music notation to see parser output';
            document.getElementById('rhythm-output').textContent = 'Enter music notation to see rhythm analyzer output';
            document.getElementById('spatial-output').textContent = 'Enter music notation to see spatial analysis output';
            document.getElementById('analyzer-output').textContent = 'Enter music notation to see analyzer output';
            document.getElementById('status').textContent = '';
            currentParseResult = null;
            
            // Clear localStorage
            saveInputText('');
            saveCursorPosition(0, 0);
            
            // Switch back to Draft tab and restore focus
            switchTab('vexflow');
        }
        
        // Initialize the application
        function initializeApp() {
            const musicInput = document.getElementById('musicInput');
            
            // Load saved input text
            const savedText = loadInputText();
            if (savedText) {
                musicInput.value = savedText;
                // Parse and render the saved text
                setTimeout(() => parseAndUpdateVexFlow(), 100);
            }
            
            // Load saved active tab (but don't trigger switchTab which interferes with cursor)
            const savedTab = loadActiveTab();
            
            // Set the active tab without calling switchTab
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.querySelector(`[onclick*="${savedTab}"]`)?.classList.add('active');
            document.getElementById(`${savedTab}-tab`)?.classList.add('active');
            
            // Set focus and restore cursor position AFTER text is loaded
            setTimeout(() => {
                restoreFocusAndCursor();
            }, 150);
            
            // Add input event listener to save text and update VexFlow as user types
            let inputTimer;
            musicInput.addEventListener('input', function(e) {
                // Convert # and b to fancy symbols when they follow musical notes
                const originalValue = this.value;
                let convertedValue = originalValue;
                
                // Convert # to â™¯ when it follows a note (number, letter, or sargam)
                convertedValue = convertedValue.replace(/([1-7A-GSRGMPDNsrgmpdnrbdb])#/g, '$1â™¯');
                convertedValue = convertedValue.replace(/([1-7A-GSRGMPDNsrgmpdnrbdb])##/g, '$1â™¯â™¯');
                
                // Convert b to â™­ when it follows a note (number, letter, or sargam) 
                convertedValue = convertedValue.replace(/([1-7A-GSRGMPDNsrgmpdnrbdb])b/g, '$1â™­');
                convertedValue = convertedValue.replace(/([1-7A-GSRGMPDNsrgmpdnrbdb])bb/g, '$1â™­â™­');
                
                if (convertedValue !== originalValue) {
                    // Save cursor position before changing text
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    
                    // Update text with fancy symbols
                    this.value = convertedValue;
                    
                    // Restore cursor position (accounting for potential symbol changes)
                    const cursorOffset = convertedValue.length - originalValue.length;
                    this.setSelectionRange(start + cursorOffset, end + cursorOffset);
                }
                
                saveInputText(this.value);
                
                // Debounce the VexFlow update to avoid too many API calls
                clearTimeout(inputTimer);
                inputTimer = setTimeout(() => {
                    if (this.value.trim()) {
                        parseAndUpdateVexFlow();
                    } else {
                        // Clear all outputs if input is empty
                        document.getElementById('vexflow-output').innerHTML = '';
                        document.getElementById('lilypond-output').textContent = 'Enter music notation above to see LilyPond source';
                        document.getElementById('document-output').textContent = 'Enter music notation to see document structure';
                        document.getElementById('parser-output').textContent = 'Enter music notation to see parser output';
                        document.getElementById('rhythm-output').textContent = 'Enter music notation to see rhythm analyzer output';
                        document.getElementById('spatial-output').textContent = 'Enter music notation to see spatial analysis output';
                        document.getElementById('analyzer-output').textContent = 'Enter music notation to see analyzer output';
                    }
                }, 300); // 300ms debounce
            });
            
            // Save cursor position only on user interaction (not on programmatic changes)
            const saveCursor = () => {
                const start = musicInput.selectionStart;
                const end = musicInput.selectionEnd;
                if (start !== undefined && end !== undefined && start >= 0 && end >= 0) {
                    saveCursorPosition(start, end);
                }
            };
            
            // Only save on direct user interaction
            musicInput.addEventListener('keyup', saveCursor);
            musicInput.addEventListener('mouseup', saveCursor);
            musicInput.addEventListener('click', saveCursor);
            
            console.log('âœ… Music Text App initialized with local storage support');
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>