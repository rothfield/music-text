// Build script to generate character widths at compile time
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    // Generate character width constants
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("char_widths.rs");

    let char_widths = measure_all_character_widths();
    fs::write(&dest_path, char_widths).expect("Failed to write char_widths.rs");

    println!("cargo:rustc-cfg=has_char_widths");
}

fn measure_all_character_widths() -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated character width measurements\n");
    output.push_str("// DO NOT EDIT - generated by build.rs\n\n");

    // For now, use reasonable estimates for Inter font at 22.4px
    // TODO: Replace with actual font measurement once build issues are resolved
    let measurements = generate_inter_estimates();

    output.push_str(&format!("pub const CHAR_WIDTHS: &[(char, f32)] = &[\n"));

    for (ch, width) in measurements {
        if ch.is_ascii_control() {
            continue; // Skip control characters
        }
        output.push_str(&format!("    ('{}', {:.2}),\n",
            if ch == '\'' { "\\'" } else if ch == '\\' { "\\\\" } else { &ch.to_string() },
            width));
    }

    output.push_str("];\n\n");

    // Generate lookup function
    output.push_str("pub fn get_char_width(c: char) -> f32 {\n");
    output.push_str("    CHAR_WIDTHS.iter()\n");
    output.push_str("        .find(|(ch, _)| *ch == c)\n");
    output.push_str("        .map(|(_, width)| *width)\n");
    output.push_str("        .unwrap_or(13.44) // Default monospace width\n");
    output.push_str("}\n");

    output
}


fn generate_inter_estimates() -> Vec<(char, f32)> {
    let mut measurements = Vec::new();

    // Inter font measurements at 22.4px (proportional widths)
    // ASCII printable characters with realistic Inter proportions
    for i in 32..=126 {
        let ch = char::from(i as u8);
        let width = match ch {
            // Very narrow characters
            'i' | 'l' | 'I' | 'j' | 't' | 'f' | '!' | '|' => 5.5,
            'r' => 7.8,   // Special handling for skinny 'r'
            '.' | ',' | ':' | ';' => 5.0,
            ' ' => 6.7,

            // Wide characters
            'M' | 'W' => 17.9,
            'm' | 'w' => 16.8,
            'G' | 'O' | 'Q' | 'D' => 15.2,

            // Sargam characters (key ones)
            'S' => 13.1,
            'R' => 13.8,
            'g' => 11.2,
            'G' => 15.2,
            'P' => 12.9,
            'd' => 11.5,
            'D' => 15.2,
            'n' => 11.2,
            'N' => 15.4,

            // Medium characters
            'A' | 'B' | 'C' | 'E' | 'F' | 'H' | 'K' | 'L' | 'N' | 'P' | 'R' | 'S' | 'T' | 'U' | 'V' | 'X' | 'Y' | 'Z' => 12.8,
            'a' | 'b' | 'c' | 'd' | 'e' | 'g' | 'h' | 'k' | 'n' | 'o' | 'p' | 'q' | 's' | 'u' | 'v' | 'x' | 'y' | 'z' => 11.2,

            // Numbers (Inter has proportional numbers)
            '1' => 6.7,
            '0' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => 11.2,

            // Default for other characters
            _ => 11.0,
        };
        measurements.push((ch, width));
    }

    // Musical symbols (might be different width in music fonts)
    let musical_symbols = [
        ('𝄀', 8.0),   // Single barline
        ('𝄁', 12.0),  // Final barline
        ('𝄆', 14.0),  // Repeat start
        ('𝄇', 14.0),  // Repeat end
        ('♯', 10.0),  // Sharp
        ('♭', 10.0),  // Flat
        ('♮', 10.0),  // Natural
        ('•', 6.0),   // Octave dot
    ];

    measurements.extend(musical_symbols.iter().cloned());
    measurements
}