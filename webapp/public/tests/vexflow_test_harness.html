<!DOCTYPE html>
<html>
<head>
    <title>VexFlow Test Harness - FSM Direct</title>
    <script src="lib/vexflow.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .test-section {
            margin-bottom: 40px;
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        textarea {
            width: 100%;
            height: 100px;
            font-family: monospace;
            font-size: 14px;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .output-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .json-output {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        
        pre {
            margin: 0;
            font-size: 12px;
        }
        
        .notation-display {
            background-color: white;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        .error {
            color: red;
            padding: 10px;
            background-color: #ffebee;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .examples {
            margin-top: 20px;
        }
        
        .example-button {
            background-color: #2196F3;
            margin-right: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>VexFlow Test Harness - Direct FSM Conversion</h1>
    
    <div class="test-section">
        <h2>Input Notation</h2>
        <div class="input-section">
            <textarea id="notation-input" placeholder="Enter notation (e.g., S R G M P)">S R G M P</textarea>
            <button onclick="parseAndRender()">Parse & Render</button>
        </div>
        
        <div class="examples">
            <h3>Quick Examples:</h3>
            <button class="example-button" onclick="loadExample('S R G M P')">Simple Sargam</button>
            <button class="example-button" onclick="loadExample('C D E F G')">Western Notes</button>
            <button class="example-button" onclick="loadExample('S - R G')">With Dashes</button>
            <button class="example-button" onclick="loadExample('S R \\' G M')">With Breathmark</button>
            <button class="example-button" onclick="loadExample('S R | G M | P D')">With Barlines</button>
            <button class="example-button" onclick="loadExample('-S- -R- -G-')">Flats</button>
            <button class="example-button" onclick="loadExample('S# R# G#')">Sharps</button>
        </div>
    </div>
    
    <div class="test-section">
        <h2>Output</h2>
        <div class="output-section">
            <div>
                <h3>FSM/VexFlow JSON</h3>
                <div class="json-output">
                    <pre id="json-output">JSON output will appear here...</pre>
                </div>
            </div>
            <div>
                <h3>VexFlow Rendering</h3>
                <div id="notation-display" class="notation-display">
                    Notation will render here...
                </div>
            </div>
        </div>
        <div id="error-display"></div>
    </div>

    <script type="module">
        // Load WASM module
        let wasmModule = null;
        
        async function initWasm() {
            try {
                const wasm = await import('./pkg/notation_parser.js');
                await wasm.default();
                wasmModule = wasm;
                console.log('WASM module loaded successfully');
            } catch (error) {
                showError('Failed to load WASM module: ' + error.message);
            }
        }
        
        window.loadExample = function(notation) {
            document.getElementById('notation-input').value = notation;
            parseAndRender();
        }
        
        window.parseAndRender = async function() {
            if (!wasmModule) {
                showError('WASM module not loaded yet. Please wait...');
                return;
            }
            
            const input = document.getElementById('notation-input').value;
            clearError();
            
            try {
                // Parse the notation
                const parseSuccess = wasmModule.parse_notation(input);
                
                if (!parseSuccess) {
                    showError('Failed to parse notation');
                    return;
                }
                
                // Get the FSM-based VexFlow output
                const vexflowJson = wasmModule.get_fsm_vexflow_output();
                
                // Display JSON
                document.getElementById('json-output').textContent = JSON.stringify(JSON.parse(vexflowJson), null, 2);
                
                // Parse and render with VexFlow
                const vexflowData = JSON.parse(vexflowJson);
                renderVexFlow(vexflowData);
                
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }
        
        function renderVexFlow(staves) {
            const { Renderer, Stave, StaveNote, Voice, Formatter, Accidental, Barline } = Vex.Flow;
            
            // Clear previous render
            const div = document.getElementById('notation-display');
            div.innerHTML = '';
            
            // Create renderer
            const renderer = new Renderer(div, Renderer.Backends.SVG);
            renderer.resize(800, 200);
            const context = renderer.getContext();
            
            let currentX = 10;
            let currentY = 40;
            
            // Process each stave
            staves.forEach((staveData, staveIndex) => {
                const stave = new Stave(currentX, currentY, 750);
                if (staveIndex === 0) {
                    stave.addClef("treble");
                }
                stave.setContext(context).draw();
                
                // Convert elements to VexFlow objects
                const notes = [];
                let currentNoteGroup = [];
                
                staveData.notes.forEach((element, i) => {
                    if (element.type === 'Note') {
                        const note = new StaveNote({
                            clef: "treble",
                            keys: element.keys,
                            duration: element.duration + (element.dots > 0 ? 'd'.repeat(element.dots) : '')
                        });
                        
                        // Add accidentals
                        if (element.accidentals) {
                            element.accidentals.forEach(acc => {
                                note.addModifier(new Accidental(acc.accidental), acc.index);
                            });
                        }
                        
                        // Handle ties (simplified - just mark the note)
                        if (element.tied) {
                            note.setStemDirection(1); // Visual indicator for now
                        }
                        
                        currentNoteGroup.push(note);
                    } else if (element.type === 'Rest') {
                        const rest = new StaveNote({
                            clef: "treble",
                            keys: ["b/4"],
                            duration: element.duration + 'r' + (element.dots > 0 ? 'd'.repeat(element.dots) : '')
                        });
                        currentNoteGroup.push(rest);
                    } else if (element.type === 'BarLine') {
                        // Flush current notes before barline
                        if (currentNoteGroup.length > 0) {
                            notes.push(...currentNoteGroup);
                            currentNoteGroup = [];
                        }
                        // VexFlow handles barlines differently - we'll skip for now
                    } else if (element.type === 'Breathe') {
                        // Add breathmark as articulation on previous note if exists
                        if (currentNoteGroup.length > 0) {
                            const lastNote = currentNoteGroup[currentNoteGroup.length - 1];
                            // In real implementation, add breathmark articulation
                        }
                    }
                });
                
                // Add remaining notes
                if (currentNoteGroup.length > 0) {
                    notes.push(...currentNoteGroup);
                }
                
                if (notes.length > 0) {
                    // Create voice and add notes
                    const voice = new Voice({ num_beats: 4, beat_value: 4, resolution: Vex.Flow.RESOLUTION });
                    voice.setMode(Voice.Mode.SOFT);
                    voice.addTickables(notes);
                    
                    // Format and draw
                    new Formatter().joinVoices([voice]).format([voice], 700);
                    voice.draw(context, stave);
                }
                
                currentY += 120;
            });
        }
        
        function showError(message) {
            document.getElementById('error-display').innerHTML = `<div class="error">${message}</div>`;
        }
        
        function clearError() {
            document.getElementById('error-display').innerHTML = '';
        }
        
        // Initialize on load
        initWasm();
    </script>
</body>
</html>