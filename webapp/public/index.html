<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Notation Parser - Text to Staff Notation</title>
    <meta name="description" content="Convert text-based music notation (Numbers, Letters, Sargam) to professional staff notation instantly">
    
    <!-- Modern CSS with CSS Variables for theming -->
    <style>
        :root {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-muted: #9ca3af;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --border-color: #e5e7eb;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Header Section */
        .hero {
            background: var(--bg-primary);
            padding: 2rem 1rem;
            text-align: center;
            box-shadow: var(--shadow-md);
        }

        .hero h1 {
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .hero p {
            font-size: clamp(1rem, 2vw, 1.125rem);
            color: var(--text-secondary);
            max-width: 600px;
            margin: 0 auto;
        }

        .notation-badges {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .badge {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid var(--border-color);
        }

        /* Main Container */
        .container {
            width: 100%;
            margin: 0;
            padding: 2rem 1rem;
        }

        /* Card Components */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            overflow: visible;  /* Allow wide content */
            margin-bottom: 2rem;
        }

        .card-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-content {
            padding: 1.5rem;
        }

        /* Input Section */
        .input-group {
            margin-bottom: 1.5rem;
        }

        .label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        #notation-input {
            width: 100%;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            font-size: 1rem;
            line-height: 1.5;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        #notation-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
        }

        #notation-input::placeholder {
            color: #000000 !important;
            opacity: 1 !important;
            font-weight: 500;
        }

        /* VexFlow Output */
        #vexflow-canvas {
            width: 100%;
            min-width: 2000px;  /* Force minimum width to match SVG */
            min-height: 200px;
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            border: 2px dashed var(--border-color);
            display: flex;
            align-items: center;
            justify-content: flex-start;  /* Left-align the wide content */
            overflow-x: auto;
            transition: border-color 0.2s ease;
        }

        #vexflow-canvas.has-content {
            border: 2px solid var(--success-color);
            border-style: solid;
        }

        #vexflow-canvas svg {
            /* Allow SVG to be its full 2000px width */
            max-width: none;
            height: auto;
        }

        .placeholder {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.875rem;
            padding: 2rem;
        }

        .placeholder-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        /* Error States */
        .error-message {
            background: rgb(254 242 242);
            border: 1px solid rgb(252 165 165);
            color: var(--error-color);
            padding: 1rem;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            margin-top: 1rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .hero {
                padding: 1.5rem 1rem;
            }
            
            .card-content {
                padding: 1rem;
            }
            
            .card-header {
                padding: 1rem;
            }
            
            .notation-badges {
                gap: 0.5rem;
            }
            
            .badge {
                padding: 0.375rem 0.75rem;
                font-size: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            #notation-input {
                font-size: 16px; /* Prevent zoom on iOS */
                padding: 0.875rem;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        /* LilyPond Button */
        .lilypond-btn {
            background-color: var(--success-color);
            color: white;
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin-right: 0.75rem;
        }

        .lilypond-btn:hover {
            background-color: #059669;
            transform: translateY(-1px);
        }

        .lilypond-btn:active {
            transform: translateY(0);
        }

        .lilypond-btn:disabled {
            background-color: #9ca3af;
            transform: none;
            cursor: not-allowed;
        }

        .source-toggle-btn {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .source-toggle-btn:hover {
            background-color: var(--bg-tertiary);
            transform: translateY(-1px);
        }

        .source-toggle-btn:active {
            transform: translateY(0);
        }

        .lilypond-source {
            margin-top: 1rem;
            display: none;
        }

        .lilypond-source.visible {
            display: block;
        }

        .source-code-display {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: var(--radius-md);
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            font-size: 0.875rem;
            overflow-x: auto;
            white-space: pre-wrap;
            border: 1px solid var(--border-color);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Server Status Indicator */
        .server-status {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: var(--bg-primary);
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            z-index: 1000;
        }

        .server-status.online {
            color: var(--success-color);
            border-color: var(--success-color);
        }

        .server-status.offline {
            color: var(--error-color);
            border-color: var(--error-color);
        }

        /* Header positioning for status indicator */
        .hero {
            position: relative;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --text-primary: #f9fafb;
                --text-secondary: #d1d5db;
                --text-muted: #9ca3af;
                --bg-primary: #1f2937;
                --bg-secondary: #374151;
                --bg-tertiary: #4b5563;
                --border-color: #4b5563;
            }
            
            body {
                background: linear-gradient(135deg, #1e3a8a 0%, #581c87 100%);
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@latest/build/vexflow.js"></script>
</head>
<body>
    <!-- Hero Section -->
    <header class="hero">
        <div id="server-status" class="server-status">
            <span id="server-indicator">üü° Checking server...</span>
        </div>
        <h1>üéµ Text to Staff Notation</h1>
        <p>Convert text-based music notation to staff notation</p>
    </header>

    <!-- Main Content -->
    <main class="container">
        <!-- Input Card -->
        <div class="card">
            <div class="card-content">
                <div class="input-group">
                    <textarea 
                        id="notation-input" 
                        placeholder="Numbers: 1-2-3-4-5-6-7
Letters: C-D-E-F-G-A-B  
Sargam: S-R-G-M-P-D-N

Try Happy Birthday:
‚Ä¢ Numbers: 5-5 | 6 5 1 | 7 - - | 5-5 | 6 5 2 | 1 - - |
           , ,   , ,     ,       , ,   , ,     
‚Ä¢ Letters: G-G | A G C | B - - | G-G | A G D | C - - |
          , ,   , ,     ,       , ,   , ,
‚Ä¢ Sargam: P-P | D P S | N - - | P-P | D P R | S - - |
         , ,   , ,     ,       , ,   , ,"
                        autocomplete="off"
                        spellcheck="false"
                    ></textarea>
                </div>
            </div>
        </div>

        <!-- VexFlow Output Card -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">
                    <span>üéº</span>
                    Live Staff Preview
                    <span id="loading-indicator" class="loading" style="display: none;"></span>
                </h2>
            </div>
            <div class="card-content">
                <div id="vexflow-canvas">
                    <div class="placeholder">
                        <span class="placeholder-icon">üéµ</span>
                        <div>Your notation will appear here as beautiful staff notation</div>
                        <div style="font-size: 0.75rem; margin-top: 0.5rem; opacity: 0.7;">
                            Start typing in the text area above
                        </div>
                    </div>
                </div>
                <div id="error-container"></div>
            </div>
        </div>

        <!-- LilyPond Generation Card -->
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">
                    <span>üìÑ</span>
                    Professional Staff Notation
                </h2>
            </div>
            <div class="card-content">
                <div style="text-align: center; margin-bottom: 1rem;">
                    <button id="generate-lilypond-btn" class="lilypond-btn">
                        Generate LilyPond
                    </button>
                    <button id="toggle-source-btn" class="source-toggle-btn">
                        Show Source
                    </button>
                </div>
                <div id="lilypond-output">
                    <div class="placeholder">
                        <span class="placeholder-icon">üìÑ</span>
                        <div>Click Generate LilyPond to create professional staff notation</div>
                    </div>
                </div>
                <div id="lilypond-source" class="lilypond-source">
                    <div style="font-weight: 500; margin-bottom: 0.5rem; color: var(--text-primary);">LilyPond Source Code</div>
                    <div id="source-code" class="source-code-display"></div>
                    <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem; text-align: center;">
                        Copy to LilyPond software for rendering
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script type="module">
        import init, { parse_notation } from './pkg/notation_parser.js';
        
        let vexflowRenderer = null;
        let context = null;
        let isInitialized = false;
        
        function showLoading(show = true) {
            const indicator = document.getElementById('loading-indicator');
            indicator.style.display = show ? 'inline-block' : 'none';
        }
        
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = `
                <div class="error-message">
                    ‚ö†Ô∏è ${message}
                </div>
            `;
        }
        
        function clearError() {
            const errorContainer = document.getElementById('error-container');
            errorContainer.innerHTML = '';
        }
        
        function initVexFlow() {
            const canvas = document.getElementById('vexflow-canvas');
            canvas.innerHTML = '';
            canvas.classList.add('has-content');
            
            const VF = Vex.Flow;
            vexflowRenderer = new VF.Renderer(canvas, VF.Renderer.Backends.SVG);
            vexflowRenderer.resize(800, 200);
            context = vexflowRenderer.getContext();
        }
        
        function resetCanvas() {
            const canvas = document.getElementById('vexflow-canvas');
            canvas.classList.remove('has-content');
            canvas.innerHTML = `
                <div class="placeholder">
                    <span class="placeholder-icon">üéµ</span>
                    <div>Your notation will appear here as beautiful staff notation</div>
                    <div style="font-size: 0.75rem; margin-top: 0.5rem; opacity: 0.7;">
                        Start typing in the text area above
                    </div>
                </div>
            `;
        }
        
        
        function renderNotation(input) {
            if (!isInitialized) return;
            
            showLoading();
            clearError();
            
            // Debounce rendering for better performance
            setTimeout(() => {
                try {
                    if (!input.trim()) {
                        resetCanvas();
                        showLoading(false);
                        return;
                    }
                    
                    const result = parse_notation(input);
                    if (!result.success) {
                        resetCanvas();
                        showError('Could not parse the notation. Please check your syntax.');
                        showLoading(false);
                        return;
                    }
                    
                    const vexflowOutput = result.vexflow_output;
                    if (!vexflowOutput) {
                        resetCanvas();
                        showError('No notation to display from the parsed input.');
                        showLoading(false);
                        return;
                    }
                    
                    // Execute Rust-generated VexFlow JavaScript directly
                    const canvas = document.getElementById('vexflow-canvas');
                    const renderVexFlow = new Function('canvas', 'VF', vexflowOutput);
                    renderVexFlow(canvas, Vex.Flow);
                    
                    showLoading(false);
                    
                } catch (error) {
                    console.error('Rendering error:', error);
                    resetCanvas();
                    showError(`Rendering error: ${error.message || 'Unknown error occurred'}`);
                    showLoading(false);
                }
            }, 300); // Debounce delay
        }
        
        let isServerOnline = false;
        
        async function checkServerStatus() {
            const serverStatus = document.getElementById('server-status');
            const serverIndicator = document.getElementById('server-indicator');
            
            try {
                const response = await fetch('/api/health', { method: 'GET' });
                if (response.ok) {
                    serverIndicator.innerHTML = 'Server Online';
                    serverStatus.className = 'server-status online';
                    isServerOnline = true;
                } else {
                    serverIndicator.innerHTML = 'Server Offline';
                    serverStatus.className = 'server-status offline';
                    isServerOnline = false;
                }
            } catch (error) {
                serverIndicator.innerHTML = 'Server Offline';
                serverStatus.className = 'server-status offline';
                isServerOnline = false;
            }
        }

        let currentLilypondSource = '';
        let isSourceVisible = false;
        
        function toggleSource() {
            const sourceSection = document.getElementById('lilypond-source');
            const toggleBtn = document.getElementById('toggle-source-btn');
            
            if (isSourceVisible) {
                sourceSection.classList.remove('visible');
                toggleBtn.textContent = 'Show Source';
                isSourceVisible = false;
            } else {
                sourceSection.classList.add('visible');
                toggleBtn.textContent = 'Hide Source';
                isSourceVisible = true;
            }
        }
        
        async function generateLilyPond() {
            const input = document.getElementById('notation-input');
            const lilypondBtn = document.getElementById('generate-lilypond-btn');
            const lilypondOutput = document.getElementById('lilypond-output');
            const sourceCode = document.getElementById('source-code');
            
            if (!input.value.trim()) {
                lilypondOutput.innerHTML = `
                    <div class="error-message">
                        ‚ö†Ô∏è Please enter some notation first
                    </div>
                `;
                return;
            }
            
            try {
                lilypondBtn.disabled = true;
                lilypondBtn.textContent = 'Generating...';
                
                const result = parse_notation(input.value.trim());
                if (!result.success) {
                    throw new Error('Could not parse notation');
                }
                
                const lilypondCode = result.lilypond_output;
                if (!lilypondCode || !lilypondCode.trim()) {
                    throw new Error('No LilyPond output generated');
                }
                
                // Always update source code
                currentLilypondSource = lilypondCode;
                sourceCode.textContent = lilypondCode;
                
                if (isServerOnline) {
                    // Server online: Try to generate PNG
                    try {
                        const response = await fetch('/api/lilypond-to-png', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ lilypondCode: lilypondCode })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            lilypondOutput.innerHTML = `
                                <div style="text-align: center;">
                                    <div style="color: var(--success-color); font-weight: 500; margin-bottom: 1rem;">‚úÖ Professional notation generated</div>
                                    <img src="${data.imageUrl}" alt="LilyPond Staff Notation" style="max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: var(--radius-md);">
                                </div>
                            `;
                            return;
                        }
                    } catch (serverError) {
                        console.log('Server PNG generation failed:', serverError);
                    }
                    
                    // PNG generation failed
                    lilypondOutput.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                            <div style="color: var(--warning-color); font-weight: 500; margin-bottom: 0.5rem;">‚ö†Ô∏è Server error - showing source code instead</div>
                            <div style="font-size: 0.875rem;">Use Show Source button to view generated code</div>
                        </div>
                    `;
                } else {
                    // Server offline
                    lilypondOutput.innerHTML = `
                        <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                            <div style="color: var(--error-color); font-weight: 500; margin-bottom: 0.5rem;">üî¥ Server offline - source code generated</div>
                            <div style="font-size: 0.875rem;">Use Show Source button to view generated code</div>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('LilyPond generation error:', error);
                lilypondOutput.innerHTML = `
                    <div class="error-message">
                        ‚ö†Ô∏è ${error.message || 'Failed to generate LilyPond notation'}
                    </div>
                `;
            } finally {
                lilypondBtn.disabled = false;
                lilypondBtn.textContent = 'Generate LilyPond';
            }
        }

        // Local storage functions
        function saveToLocalStorage(notation) {
            try {
                const settings = {
                    notation: notation,
                    timestamp: Date.now()
                };
                localStorage.setItem('musicNotationSettings', JSON.stringify(settings));
            } catch (e) {
                console.error("Failed to save to local storage:", e);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const savedSettings = localStorage.getItem('musicNotationSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    const input = document.getElementById('notation-input');
                    if (settings.notation && input) {
                        input.value = settings.notation;
                        return settings.notation;
                    }
                }
            } catch (e) {
                console.error("Failed to load from local storage:", e);
            }
            return '';
        }

        async function setupApp() {
            try {
                showLoading();
                await checkServerStatus();
                
                // Check server status periodically
                setInterval(checkServerStatus, 5000);
                
                await init({ module_or_path: './pkg/notation_parser_bg.wasm' });
                isInitialized = true;
                
                const input = document.getElementById('notation-input');
                const lilypondBtn = document.getElementById('generate-lilypond-btn');
                
                // Load saved notation from localStorage
                const savedNotation = loadFromLocalStorage();
                if (savedNotation) {
                    input.value = savedNotation;
                }
                
                // Render initial notation only if there's content
                if (input.value.trim()) {
                    renderNotation(input.value);
                }
                
                // Update on input with debouncing
                let debounceTimer;
                input.addEventListener('input', (e) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        renderNotation(e.target.value);
                        saveToLocalStorage(e.target.value);
                    }, 150);
                });
                
                // Handle focus and blur for mobile
                input.addEventListener('focus', () => {
                    input.select();
                });
                
                // LilyPond generation button
                lilypondBtn.addEventListener('click', generateLilyPond);
                
                // Source toggle button
                const toggleBtn = document.getElementById('toggle-source-btn');
                toggleBtn.addEventListener('click', toggleSource);
                
                showLoading(false);
            } catch (error) {
                console.error('Setup error:', error);
                showError(`Failed to initialize: ${error.message || 'Please refresh the page'}`);
                showLoading(false);
            }
        }
        
        setupApp();
    </script>
</body>
</html>